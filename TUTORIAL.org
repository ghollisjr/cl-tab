* Introduction
cl-tab is a Common Lisp library designed to facilitate
tabular/structured data analysis using a combination of

1. In-memory processing through Common Lisp software.
2. Any number of database servers that support a SQL connection.

To this end, the following capabilities are provided:

- Tables: Tables as data containers are supported with similar
  functionality as that provided through e.g. Python's Pandas.

- Table I/O: Table I/O to CSV files and SQL connections are supported.
  This includes returning tables from SQL queries as well as sending
  queries to create tables along with data insertion to a SQL server.

- SQL operations: All ANSI SQL operations on in-memory tables are
  supported through a functional API along with a handful of useful
  variations or extensions of those operations.

- Database connection management: A simple API for managing SQL server
  connections is provided so as to simplify projects that require
  connections to multiple servers.

cl-tab uses clsql as a backend, and is designed to interface smoothly
with cl-ana, although cl-ana's symbols are not exposed directly by
cl-tab's package.  When combined with cl-ana.makeres, it is possible
to greatly simplify writing code for data analysis, since dependency
management will be automatically handled along with logging analysis
results.

* Installation & Load:
Install quicklisp for dependencies, and then download the source and
either load the cl-tab.asd file into lisp, or setup the path
(e.g. edit

~/.config/common-lisp/source-registry.conf.d/projects.conf

on Linux).

To load: Run

#+begin_src lisp
  (ql:quickload :cl-tab)
  ;; used in this tutorial, advanced users can manage packages:
  (in-package :tb)
#+end_src

* Tables
Tables are the backbone of cl-tab.  Tables can be created via
=#'make-table=.

** Basic Table Usage:

Create a table
| x | y |
|---+---|
| 1 | 2 |
| 3 | 4 |
#+begin_src lisp
  (make-table '((1 2) (3 4)) :field-names '("x" "y"))
  ;; plists are also supported:
  (make-table '((:|x| 1 :|y| 2)
                (:|x| 3 :|y| 4)))
#+end_src

Note: Field names are guaranteed to be unique.  If a duplicate field
name is supplied, it will be prefixed with '.' until it no longer
collides with another field name.  E.g.
#+begin_src lisp
  (make-table '((1 2)) :field-names '("x" "x"))
  ;; ==> Field names are ("x" ".x"), not ("x" "x")
  (make-table '((1 2 3)) :field-names '("x" "x" "x"))
  ;; ==> Field names are ("x" ".x" "..x"), not ("x" "x" "x")
#+end_src

Copy a table
#+begin_src lisp
  ;; Assuming tab is a table, make a copy (including data):
  (make-table tab)
  ;; Can also copy only the structure, no data:
  (make-table tab :empty-p t)
  ;; Or you can copy the data, but change the field names:
  (make-table tab :field-names '("new-name1" "new-name2"))
#+end_src

Access table data:
#+begin_src lisp
  ;; Get row 0 as a plist:
  (tref tab 0)
  ;; Or as a list:
  (tref tab 0 :type 'list)
  ;; Or as a vector:
  (tref tab 0 :type 'vector)

  ;; Get rows 0, 1, 2 as a list of plists:
  (tref tab (list 0 1 2))
  ;; Like above, :type can be used to change row data type:
  (tref tab (list 0 1 2) :type 'list)

  ;; Get column "x" as list:
  (tref tab "x") ; columns default to list since plist makes no sense
  ;; Or as a vector:
  (tref tab "x" :type 'vector)

  ;; Get multiple columns as list of lists:
  (tref tab (list "x" "y" "z"))
#+end_src

Insert table data: (Table is modified)
#+begin_src lisp
  ;; Insert a new row into table
  (insert! tab
           (list :|x| 1 :|y| 2))
  ;; Can insert multiple rows:
  (insert! tab
           (list :|x| 1 :|y| 2)
           (list :|x| 3 :|y| 4))
#+end_src

Delete table data: (Table is modified)
#+begin_src lisp
  ;; Delete first row from table:
  (delete! tab 0)
  ;; Delete multiple rows from table:
  (delete! tab (list 0 1 2))
  ;; Delete rows using a condition function:
  (delete! tab
           ;; Note: tlambda is a useful function creation operator for
           ;; working with tables.  More on this later.
           ;;
           ;; This example uses (> |x| |y|) as the deletion condition.
           (tlambda (|x| |y|) (> |x| |y|)))
#+end_src

Truncate table: (i.e. delete all rows; table is modified)
#+begin_src lisp
  ;; Much more efficient than e.g. (delete! tab (constantly t))
  (truncate! tab)
#+end_src
** CSV I/O
Alternatively, tables can be read from a CSV file:
#+begin_src lisp
  (with-open-file (f "/path/to/data.csv")
    (read-csv f))
#+end_src

Or written to them:
#+begin_src lisp
  ;; assuming tab is a table:
  (with-open-file (f "/path/to/data.csv"
                     :direction :output
                     :if-does-not-exist :create
                     :if-exists :supersede)
    (write-csv tab :stream f))
#+end_src

Notes:
- =#'write-csv= will return a string by default.
- =#'read-csv= and =#'write-csv= formatting defaults to Lisp style, so
  that data can automatically be read back from the file as it was
  when it was written.  To override this, use =:lisp-p nil= as a
  keyword argument.  This is useful when e.g. data is not formatted as
  valid Lisp data and must be parsed, or when data is meant for
  external tools like MS Excel.
** SQL I/O
Tables can also be retrieved and sent through SQL database
connections.  For details on establishing connections, see the
Database section.

Assuming a connection has already been established, here are SQL I/O
examples:

#+begin_src lisp
  ;; Get table from SQL server via query:
  (query "select * from tab")

  ;; Write table data from local table `tab` to a SQL server table also
  ;; named `tab`:
  (table->sql tab "tab") ; can also specify schema or database if server allows
#+end_src
** org-mode output
As a convenience for printing tables, =#'table->org= allows output to
table data formatted as per Emacs's org-mode:
#+begin_src lisp
(table->org tab)
#+end_src
* Database connections
cl-tab uses clsql as a backend to provide SQL connections, and
additionally provides

- =#'tb:query=: A function which wraps the functionality of
  =#'clsql:query= and =#'clsql:execute-command= such that the returned
  result is a tb:table, or, is optionally ignored.

- =define-database=: A macro that simplifies database management by
  defining a function that acts just like =#'tb:query=, but using a
  specific database connection specified on definition as well as
  allowing disconnect by sending the argument =:disconnect= instead of
  a query argument.

Example usages:
#+begin_src lisp
  ;; Connect to a PostgreSQL Chinook database using clsql and use
  ;; tb:query to return a table result:
  (clsql:connect '("localhost" "chinook" "user" "password")
                 :database-type :postgresql)
  (query "select * from customer") ; we're in the :tb package
  ;; => tb:table result

  ;; Define a specific connection to the chinook PostgreSQL database and
  ;; use that database query function:
  (define-database chinook
    (clsql:connect '("localhost" "chinook" "user" "password")
                 :database-type :postgresql))
  (chinook "select * from customer") ; returns tb:table
  (chinook :disconnect) ; disconnect via this argument
  (chinook "select * from customer") ; automatic reconnection

  ;; What is the connection information for #'chinook?
  (chinook :info)
  ;; What about just the connection object?
  (chinook :conn)
#+end_src

Additionally, =#'tb:query= and database query functions defined with
=define-database= allow lists of queries as arguments, returning a
list of tables:
#+begin_src lisp
  (query (list "select 1"
               "select 2")) ; => list of two tables
  ;; One might use this to easily define unions of multiple queries,
  ;; e.g.:
  (union (query (list "select 1" "select 2"))) ; returns union of results
#+end_src
As mentioned previously, tables can be sent to a SQL server via
=#'table->sql=.  This function generates queries to create a new table
and then insert data into it using data from the local table supplied
as an argument.  Because some tables may be large and thus performance
may suffer if every single row required a query, the =:batch-size=
argument allows more fine-tuned control:

#+begin_src lisp
  ;; Write a large table in batches of 50 rows/query:
  (table->sql big-table
              :batch-size 50)

  ;; Example where we want to use the chinook connection instead:
  (table->sql big-table
              :batch-size 50
              :database (chinook :conn))

#+end_src

The rest of the arguments should be clear from the documentation,
e.g. =(documentation #'chinook 'function)= (you can inspect functions
returned by =define-datbase=).
* SQL Operations on Tables
All ANSI SQL operations are supported by a functional API.  Rows are
returned as plists, and functions from the user are also generally
expected to return plists unless special arguments are provided which
override this.

A key macro to assist in making lambda functions easier to write so
that they automatically handle table row plist arguments and also
provide useful macros & symbol macros for working with table data is
=tlambda=.  =tlambda= can be used to created functions as follows:

#+begin_src lisp
  (tlambda (field1 field2 ...)
    ;; do something with fields
    )
#+end_src

and effectively wraps whatever field symbols you provide in something
like

#+begin_src lisp
  (lambda (&key field1 field2 ... &allow-other-keys)
    ;; do something with fields
    )
#+end_src

with the additional context that there are also macros and symbol
macros defined:

- =fields= is a symbol macro that returns the entire row as a plist.
  It is setf-able.
- =(fields <field-name-or-symbol>)= is a macro that returns a specific
  field referenced by the name or symbol.  It is setf-able.

Having mentioned =tlambda=, here are examples for each of the SQL
operations using SQL and this library.
** SELECT
SELECT is sometimes as easy as returning the table.  Other times,
=#'tmap= is needed.
#+begin_src lisp
   ;; select * from tab;
   tab ; easy case

   ;; select x, y from tab;
   (tmap (tlambda (|x| |y|)
           (list :|x| |x|
                 :|y| |y|))
         tab)

   ;; select *, x+y as "z" from tab;
   (tmap (tlambda (|x| |y|)
           (append fields
                   (list :|z| (+ |x| |y|))))
         tab)
   ;; Could also do this:
   (tmap (tlambda () ; no need for args this time
           (append fields
                   (list :|z| (+ (field |x|)
                                 (field |y|)))))
         tab)
#+end_src
** SELECT DISTINCT ...
Distinct selections are provided by =#'distinct=:
#+begin_src lisp
  ;; select distinct * from tab;
  (distinct tab)

  ;; select distinct x, y from tab;
  (distinct tab
            :row-fn (tlambda (|x| |y|)
                      (list :|x| |x| 
                            :|y| |y|)))

  ;; For distinct row-fn, can also just return list instead of plist:
  (distinct tab
            :row-fn (tlambda (|x| |y|)
                      (list |x| |y|)))
#+end_src
** SELECT ... WHERE
Selections with a constraint are accomplished via #'filter and
possibly #'tmap.

#+begin_src lisp
  ;; select * from tab where x > y;
  (filter (tlambda (|x| |y|)
            (> |x| |y|)
            tab)
  ;; select z from tab where x+y<z;
  (tmap (tlambda (|z|) |z|)
        (filter (tlambda (|x| |y| |z|)
                  (< (+ |x| |y|) |z|))
                tab))
#+end_src

** SELECT ... GROUP BY ...
Aggregations and grouped aggregations are supported via =#'agg= and
the helpful macro =with-agg=.

#+begin_src lisp
  ;; select sum(x) as "sum(x)" from tab
  (agg (with-agg () ; group binding (not needed this time)
           ((sum-x (agg-sum))) ; aggregate function bindings
           (list :|sum(x)| sum-x) ; result row per-group
           (|x|) ; per-row tlambda bindings
         (sum-x |x|)) ; per-row tlambda body
       tab)

  ;; select sum(x) as "sum(x)", y from tab group by y
  (agg (with-agg |y| ; group binding
           ((sum-x (agg-sum))) ; aggregate function bindings
           (list :|sum(x)| sum-x
                 :|y| |y|) ; result row per-group
           (|x|) ; per-row tlambda bindings
         (sum-x |x|)) ; per-row tlambda body
       tab
       :group-fn (tlambda (|y|) |y|)) ; value to group by

  ;; select count(*) as "count", sum(x) as "sum(x)", y, z from tab group by y, z
  (agg (with-agg y-z ; group binding
           (;; since 'count is cl symbol, have to change to count*
            (count* (agg-count)) ; aggregate function bindings
            (sum-x (agg-sum)))
           (list :|count| count*
                 :|sum(x)| sum-x
                 :|y| (first y-z)
                 :|z| (second y-z)) ; result row per-group
           (|x|) ; per-row tlambda bindings
         ;; per-row tlambda body
         (sum-x |x|)
         (count* t)) ; agg-count needs argument to actually count
       tab
       :group-fn (tlambda (|y| |z|) (list |y| |z|))) ; group by list of values
#+end_src
Aggregations are by far the ugliest part of the API, and it ultimately
stems from being a combination of grouping, mapping, and aggregating
simultaneously.  I hope to improve the aggregation API in the future.

** SELECT ... GROUP BY ... HAVING
This is just a filter after an aggregation, e.g.
#+begin_src lisp
  ;; select sum(x) as "sum(x)", y from tab group by y having y>0;
  (filter (tlambda (|y|) (> |y| 0))
          (agg (with-agg |y|
                   ((sum-x (agg-sum)))
                   (list :|sum(x)| sum-x
                         :|y| |y|)
                   (|x|)
                 (sum-x |x|))
               tab
               :group-fn (tlambda (|y|) |y|)))
#+end_src
** INSERT INTO tab VALUES ...
Insertion is provided via =#'insert!= as described in the earlier
section on basic table usage.  However, =#'insert!= only supports
plists or lists as input, not tables.  As an example to show how to
use tables as input:
#+begin_src lisp
  ;; insert into tab1 select * from tab2;
  (apply #'insert! tab1 (table->plist tab2))
#+end_src

** JOIN
Joins are supported by the =#'join= and =#'on= functions.  There are
two different join operations:

- loop join: Works for all types of join conditions, but is slow
  (nested loop over both tables).

- hash equijoin: Works only for equivalence joins, but is fast (hashed
  values join).
#+begin_src lisp
  ;; select * from a join b on a.x = b.y
  ;; Using a loop join:
  (join a
        (on b
            ;; single condition function means loop join
            (tlambda (|x| |y|)
              (equal |x| |y|))))
  ;; Using a hash equijoin:
  (join a
        (on b
            ;; list of 2 condition functions means hash join
            (list (tlambda (|x|) |x|)
                  (tlambda (|y|) |y|))))

  ;; select * from a join b on a.x = b.x and a.y = b.y
  (join a
        (on b
            ;; hashing lists of values
            (list (tlambda (|x| |y|)
                    (list |x| |y|))
                  (tlambda (|x| |y|)
                    (list |x| |y|)))))
#+end_src
Joins default to inner, as generally true for SQL.

For left, right, and outer joins, pass =:type <type keyword>= to
=#'on=, e.g.
#+begin_src lisp
  ;; select * from a left join b on a.x = b.y
  (join a
        (on b
            ;; loop join
            (tlambda (|x| |y|)
              (equal |x| |y|))
            :type :left)) ; left outer join
  ;; select * from a full join b on a.x = b.y
  (join a
        (on b
            ;; hash join
            (list (tlambda (|x|) |x|)
                  (tlambda (|y|) |y|))
            :type :full)) ; full outer join
#+end_src

For loop joins, the unique field names behavior is of special
importance, as tables with shared field names will have their fields
passed with modified symbols to the loop join condition function as
described before by prefixing each clashing symbol with a
#\. character.

E.g.
#+begin_src lisp
  ;; select * from a join b on a.x = b.x
  (join a
        (on b
            (tlambda (|x| |.x|) ; .x is from b due to clashing field names
              (equal |x| |.x|))))

  ;; But, for hash equijoins this is not a concern:
  (join a
        (on b
            (tlambda (|x|) |x|)
            (tlambda (|x|) |x|))) ; x from b can be referenced directly
#+end_src

In practice, this is seldom a concern due to the rarity of the
combined needs of a loop join and clashing field name comparison.

** DELETE FROM ... / TRUNCATE TABLE ...
Deletion and truncation are supported by =delete!= and =truncate!= as
described in the earlier section.  They modify the table data, hence
the ! suffix.

E.g.
#+begin_src lisp
  ;; delete from tab where x > 1
  (delete! tab (tlambda (|x|) (> |x| 1)))

  ;; truncate table tab
  (truncate! tab)
#+end_src

** UNION / UNION ALL
Union & union all are supported via =#'union=:
#+begin_src lisp
  ;; select * from a union select * from b;
  (union (list a b))

  ;; select * from a union all select * from b;
  (union (list a b) :all-p t)
#+end_src

** EXCEPT
Table differences are provided via =#'table-difference= or the
shorthand =#'tdiff=:
#+begin_src lisp
  ;; select * from a except select * from b
  (tdiff a b)

  ;; If more complex selections used, need tmap:
  ;; select x, y from a except select x, y from b
  (tdiff (tmap (tlambda (|x| |y|) (list :|x| |x| :|y| |y|)) a)
         (tmap (tlambda (|x| |y|) (list :|x| |x| :|y| |y|)) b))
#+end_src

For convenience, since symmetric differences are often desired, they
are supported via the =:symmetric-p= keyword argument:
#+begin_src lisp
  ;; (select * from a except select * from b)
  ;; union all
  ;; (select * from b except select * from a)
  (tdiff a b :symmetric-p t)
#+end_src
** ALTER TABLE ... ADD <column>
Adding columns is accomplished by =#'add-field!=:
#+begin_src lisp
  ;; alter table tab add x int;
  (add-field! tab "x")

  ;; add a new column with list of values:
  (add-field! tab "x" (list 1 2 3))

  ;; add a new column with a fixed value:
  (add-field! tab "x" 1)

  ;; add a new column which is a function of existing columns:
  (add-field! tab "x" (tlambda (|a| |b|) (+ |a| |b|)))
#+end_src

** ALTER TABLE ... DROP COLUMN <column>
Dropping columns is accomplished by =#'del-field!=:
#+begin_src lisp
  ;; alter table tab drop column x;
  (del-field! tab "x") ; using field name
  (del-field! tab 0) ; using field index
#+end_src

For dropping multiple columns, call =#'del-field!= on each column
which should be removed, e.g.:
#+begin_src lisp
  ;; alter table tab drop column x, y, ...;
  (dolist (c columns-to-drop)
    (del-field! tab c))
#+end_src
